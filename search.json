[{"title":"排序算法","date":"2021-02-19T03:05:55.753Z","url":"/2021/02/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/tags/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"content":"排序算法：一、冒泡排序 二、选择排序 三、插入排序 四、希尔排序分组插入排序，最开始以间隔为长度一半分组，每组插入排序，然后间隔再一半再分组，直到间隔为1， 里面的插入相当于把普通插入排序1改成间隔，但是第二个for里面不改，是i++ 不是把每个组拿出来，往自己组做插入排序 5往9插，4往8插，3往7插，2往6插，1往5和9插，来实现每间隔组插入排序 如果原始数据的大部分元素已经排序,那么插入排序的速度很快(因为需要移动的元素很少) 为什么“快” 无序的时候，元素少 元秦多的时候，已经基本有序 五、快速排序\\1. 分解:数组A[p..r]被划分为两个子数组A[p. .q-1]和A[q+1,r],使得A[q]为大小居中的数，左侧A[p. .q-1]中的每个元素都小于等于它，而右侧A[q+1,r]中 的每个元素都大于等于它。其中计算下标q也是划分过程的一部分。 解决:通过递归调用快速排序，对子数组A[p. .q-1]和A[q+1,r]进行排序 合并:因为子数组都是原址排序的，所以不需要合并，数组A[p. .r]已经有序 那么,划分就是问题的关键 快排的划分算法1.一遍单向扫描法一遍扫描法的思路是，用两个指针将数组划分为三个区间 扫描指针(scan_pos)左边是确认小于等于主元的 扫描指针到某个指针(next_bigger_pos)中间为未知的，因此我们将第二个指针(next_bigger_pos) 称为未知区间末指针，末指针的右边区间为确认 大于主元的元素 2.双向扫描法双向扫描的思路是,头尾指针往中间扫3描,从左找到大于主元的元素,从右找到小于等于主元的元素二者交换,继续扫描,直到左侧无大元素,右侧无小元素 3.严蔚敏教材交换法附设两个指针low和high，它们的初值分别为low和high，设枢轴记录的关键字为pivotkey，则首先从high所指位置起向前搜索找到第一个关键字小于 pivotkey的记录和枢轴记录互相交换，然后从low所指位置起向后搜索，找到第一个关键字大于pivotkey的记录和枢轴记录互相交换，重复这两步直至 low=high为止。 4.严蔚敏教材赋值法具体实现上述算法时，每交换一对记录需进行3次记录移动(赋值)的操作。而实际上,在排序过程中对枢轴记录的赋值是多余的，因为只有在一趟排序结 束时，即low=high的位置才是枢轴记录的最后位置。由此可改写上述算法，先将枢轴记录暂存在r[0]的位置上，排序过程中只作r[Iow]或r[high]的单向移 动，直至一趟排序结束后再将枢轴记录移至正确位置上。 六、归并排序归并排序(Merge Sort)算法完全依照了分治模式 分解:将n个元素分成各含n/2个元素的子序列; 解决:对两个子序列递归地排序; 合并:合并两个已排序的子序列以得到排序结果 和快排不同的是 归并的分解较为随意 重点是合并 七、桶排序一句话:通过”分配”和”收集”过程来实现排序 思想是:设计k个桶( bucket) ( 编号0~k-1 ) ,然后将n个输入数分布到各个桶中去,对各个桶中的数进行排序,然后按照次序把各个桶中的元素列出来即可。 八、基数排序思路：是一种特殊的桶排序 初始化0-9号十个桶 一、按个位数字，将关键字入桶，入完后，依次遍历10个桶，按检出顺序回填到数组中，如 321 322 331 500 423 476 926 检出后数组序列为： 500 321 331 423 476 926，然后取十位数字重复过程一，得到 检出后数组序列为： 500 321 423 926 331 476，然后取百位数字重复过程一，得到 检出后数组序列为： 321 331 423 476 500 926，已然有序 但是我们应该继续入桶，不过因为再高位全部是0了，这些元素会按顺序全部进入0号桶，这时0号桶的size==数组的size，这时结束标志 最后再回填到数组，数组就是升序排列的了 时间复杂度： 假设最大的数有k位，就要进行k次入桶和回填，每次入桶和回填是线性的，所以整体复杂度为kN, 其中k为最大数的10进制位数 空间复杂度：桶是10个，10个桶里面存n个元素，这些空间都是额外开辟的，所以额外的空间是N+k，k是进制 肯定是非原址的了 稳定性：假设有相等的元素，它们会次第入桶，次第回数组，不会交叉，所以是稳定的 排序算法的总结： 1.基础排序：a.冒泡 谁大谁上，每一轮都把最大的顶到天花板 效率太低O(n²)——掌握swap b.选择排序，效率较低，但经常用它内部的循环方式来找最大值和最小值——怎么一次性求出数组的最大值和最小值 O(n²) c.插排，虽然平均效率低， 但是在序列基本有序时，它很快，所以也有其适用范围 Arrays这个工具类在1.7里面做了较大改动 d.希尔（缩小增量排序），是插排的改良，对空间思维训练有帮助 2.分治法：1.子问题拆分 2.递归求解子问题 3.合并子问题的解 e.快排是软件工业中最常见的常规排序法，其双向指针扫描和分区算法是核心， 往往用于解决类似问题，特别地partition算法用来划分不同性质的元 素， partition-&gt;selectK,也用于著名的top问题 O(NlgN)，但是如果主元不是中位数的话，特别地如果每次主元都在数组区间的一侧，复杂度将退化为N² 工业优化：三点取中法，绝对中值法，小数据量用插入排序 快排重视子问题拆分 f.归并排序，空间换时间——逆序对数 归并重视子问题的解的合并 g.堆排序，用到了二叉堆数据结构，是继续掌握树结构的起手式 =插排+二分查找 上面三个都是NlgN的复杂度，其中快排表现最好，是原址的不用开辟辅助空间；堆排也是原址的，但是常数因子较大，不具备优势。 上面7种都是基于比较的排序，可证明它们在元素随机顺序情况下最好是NlgN的，用决策树证明 下面三个是非比较排序，在特定情况下会比基于比较的排序要快： 1.计数排序，可以说是最快的：O(N+k),k=maxOf(sourceArr)， 用它来解决问题时必须注意如果序列中的值分布非常广（最大值很大，元素分布很稀 疏）， 空间将会浪费很多 所以计数排序的适用范围是：序列的关键字比较集中，已知边界，且边界较小 2.桶排序：先分桶，再用其他排序方法对桶内元素排序，按桶的编号依次检出。（分配-收集） 用它解决问题必须注意序列的值是否均匀地分布在桶 中。 如果不均匀，那么个别桶中的元素会远多于其他桶，桶内排序用比较排序，极端情况下，全部元素在一个桶内 还是会退化成NlgN 其时间复杂度是：时间复杂度： O(N+C)，其中C=N(logN-logM)，约等于NlgN N是元素个数，M是桶的个数。 3.基数排序，kN级别（k是最大数的位数）是整数数值型排序里面又快又稳的，无论元素分布如何， 只开辟固定的辅助空间（10个桶） 对比桶排序，基数排序每次需要的桶的数量并不多。而且基数排序几乎不需要任何“比较”操作，而桶排序在桶相对较少的情况下， 桶内多个数据必须 进行基于比较操作的排序。 因此，在实际应用中，对十进制整数来说，基数排序更好用。 期望水准： 1、准确描述算法过程 2、写出伪代码 3、能分析时间复杂度 4、能灵活应用（知道优缺点和应用场景） 在查找算法中，基于比较的查找算法最好的时间复杂度也是O(logN)。 比如折半查找、平衡二叉树、红黑树等。 但是Hash表却有O(C)线性级别的查找 效率(不冲突情况下查找效率达到O(1))。 "},{"title":"最长连续递增子序列(部分有序)","date":"2021-02-18T15:00:07.237Z","url":"/2021/02/18/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97(%E9%83%A8%E5%88%86%E6%9C%89%E5%BA%8F)/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/tags/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"content":"最长连续递增子序列(部分有序)题目描述：(1,9,2,5,7,3,4,6,8,0)中最长的递增子序列为(3,4,6,8)。 输入: [1,3,5,4,7] 输出: 3 解释: 最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔 开。 输入: [2,2,2,2,2] 输出: 1 解释: 最长连续递增序列是 [2], 长度为1。 分析：代码："},{"title":"在有空字符串的有序字符串数组中查找","date":"2021-02-18T14:20:07.281Z","url":"/2021/02/18/%E5%9C%A8%E6%9C%89%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%89%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/tags/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"content":"在有空字符串的有序字符串数组中查找题目描述：有个排序后的字符串数组,其中散布着一些空字符串,编写-一个方法,找出给定字符串(肯定不是空字符串)的索引。 分析：在定中的过程中，若定到空的字符串，可以左移或者右移直到有数为止 代码： compareTo() 方法用于两种方式的比较： 字符串与对象进行比较。 按字典顺序比较两个字符串。 如果参数字符串等于此字符串，则返回值 0； 如果此字符串小于字符串参数，则返回一个小于 0 的值； 如果此字符串大于字符串参数，则返回一个大于 0 的值。 "},{"title":"旋转数组的最小数字(改造二分法)","date":"2021-02-18T13:08:27.473Z","url":"/2021/02/18/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97(%E6%94%B9%E9%80%A0%E4%BA%8C%E5%88%86%E6%B3%95)/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/tags/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"content":"旋转数组的最小数字(改造二分法)问题描述：把一个数组最开始的若干个元素搬到数组的末尾,我们称之为数组的旋转。输入-一个递增排序的数组的一个旋转,输出旋转数组的最小元素。例如数组 {3,4,5,1,2}为{1,2,3,4,5}的一 个旋转,该数组的最小值为1 分析： 利用数组的有序性来提升算法的性能，旋转分开的两部分一定有一部分是有序的，通过观察，最小的数一定是在无序的那一边 递归到最后两个数的时候，最小的数一定是在右边 代码： 若中间的值和左边的值和右边的值相等比如1，0，1，1，1那么应该放弃这个算法，采用扫描法"},{"title":"小白上楼梯(递归设计)","date":"2021-02-18T12:14:59.084Z","url":"/2021/02/18/%E5%B0%8F%E7%99%BD%E4%B8%8A%E6%A5%BC%E6%A2%AF(%E9%80%92%E5%BD%92%E8%AE%BE%E8%AE%A1)/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/tags/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"content":"题目描述：小白正在上楼梯，楼梯有n阶台阶，小白一次可以上1阶，2阶或者3阶，实现一个方法,计算小白有多少种走完楼梯的方式。 提示：设n阶台阶的走法数为f(n)。如果只有1个台阶，走法有1种（一步上1个台阶），即f(1)=1；如果有2个台阶，走法有2种（一种是上1阶，再上1 阶，另一种是一步上2阶），即f(2)=2；如果有3个台阶，走法有4种（一种每次1阶，共一种；另一种是2+1，共两种；第三种是3，共1种），即 f(3)=4； 当有n个台阶（n&gt;3）时，我们缩小问题规模，可以这样想：最后一步有三种情况，走1步（之前上了n-1个台阶，走法为f(n-1)种），走2步（之前上了 n-2个台阶，走法为f(n-2)种），走3步，（之前上了n-1个台阶，走法为f(n-3)种，f(n)=f(n-1)+f(n-2)+f(n-3),n&gt;3 代码："},{"title":"二分查找递归解法","date":"2021-02-16T14:30:23.110Z","url":"/2021/02/16/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/tags/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"content":"二分查找递归解法全范围内二分查找 等价于三个子问题： 左边找（递归） 中间比 右边找（递归） 注意：左查找和右查找只选其一 找重复 1、找到一种划分方法 2、找到递推公式或者等价转换 都是父问题转化为求解子问题 找变化的量 变化的量通常要作为参数 找到出口 根据参数变化的趋势，对边界进行控制，适时终止递归"},{"title":"汉诺塔","date":"2021-02-09T06:44:12.819Z","url":"/2021/02/09/%E6%B1%89%E8%AF%BA%E5%A1%94/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/tags/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"content":"问题描述：相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。 分析：1-N从A移动到B，C作为辅助 等价于： 1、1~N-1从A移动到C，B为辅助 2、把N从A移动到B 3、1-N-1从C移动到B，A为辅助 在这里插入图片描述 "},{"title":"出现k次和出现1次的数","date":"2021-02-03T09:20:49.034Z","url":"/2021/02/03/%E5%87%BA%E7%8E%B0k%E6%AC%A1%E5%92%8C%E5%87%BA%E7%8E%B01%E6%AC%A1%E7%9A%84%E6%95%B0/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/tags/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"content":"题目描述：数组中只有一个数出现了1次，其他的数都出现了k次，请输出出现了1次的数 分析：这道题有很多种做法，但是这里我们只考虑如何利用进制的方法去做，多的也不说，大家只要记住一个结论k个相同的k进制数做不进位加法结果为 0。举个例子，3个相同的三进制数，假设个这个数是2，2的三进制是011，所以三个011做不进位加法结果就是011+011+011=000；再比方说10个十 进制数相加，假设这个数是10，做不进位加法最后结果也是0 "},{"title":"乘2挪整：二进制表示浮点实数","date":"2021-02-03T09:17:16.647Z","url":"/2021/02/03/%E4%B9%982%E6%8C%AA%E6%95%B4%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B5%AE%E7%82%B9%E5%AE%9E%E6%95%B0/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/tags/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"content":"题目描述：给定一个介于0和1之间的实数，（如0.625），类型为double，打印他的二进制表示（0.101），如果该数字无法精确地用32位以内地二进制表示， 则打印“ERROR” 分析：因为二进制左移是乘二，右移是除二，0.101（二进制）也就是0.5+0.125=0.625 浮点数求二进制实际上就是除二取余的逆运算，先把原数乘二，0.625*2=1.25，小数点前面有1，就把那个1干掉，输出0.1，剩下0.25，再乘二等于0.5不足1，故在后面加0，这时输出为0.10，0.5再乘二恰好是1.0那么同上干掉1，输出为0.101 "},{"title":"将整数的奇偶位互换","date":"2021-02-02T07:34:37.150Z","url":"/2021/02/02/%E5%B0%86%E6%95%B4%E6%95%B0%E7%9A%84%E5%A5%87%E5%81%B6%E4%BD%8D%E4%BA%92%E6%8D%A2/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/tags/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["查找与排序","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"]],"content":"题目描述：将整数的奇偶位互换，假设这个数是9，二进制就是1001，那么得到的结果就是0110 分析：首先我们需要两个个数 a = 0x55555555 b = 0xaaaaaaaa a和b都是16进制数，转换为二进制分别是0101 0101 0101…，1010 1010 1010…（因为1010对应的十进制是10，而10在16进制中是a，0101也同 理），然后将需要改变的数n分别对a和b进行&amp;运算得到c和d，然后将c向左移1位，将d向右移1位，再分别进行异或，就得到所求结果，看下面示例 "},{"title":"数的读法","date":"2021-01-27T07:29:37.485Z","url":"/2021/01/27/%E6%95%B0%E7%9A%84%E8%AF%BB%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["基础","/tags/%E5%9F%BA%E7%A1%80/"],["判断","/tags/%E5%88%A4%E6%96%AD/"],["函数","/tags/%E5%87%BD%E6%95%B0/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"题目描述：Tom教授正在给研究生讲授一门关于基因的课程，有一件事情让他颇为头疼：一条染色体上有成千上万个碱基对，它们从0开始编号，到几百万，几千万，甚至上亿。 比如说，在对学生讲解第1234567009号位置上的碱基时，光看着数字是很难准确的念出来的。 所以，他迫切地需要一个系统，然后当他输入12 3456 7009时，会给出相应的念法： 十二亿三千四百五十六万七千零九 用汉语拼音表示为 shi er yi san qian si bai wu shi liu wan qi qian ling jiu 这样他只需要照着念就可以了。 你的任务是帮他设计这样一个系统：给定一个阿拉伯数字串，你帮他按照中文读写的规范转为汉语拼音字串，相邻的两个音节用一个空格符格开。 注意必须严格按照规范，比如说“10010”读作“yi wan ling yi shi”而不是“yi wan ling shi”，“100000”读作“shi wan”而不是“yi shi wan”，“2000”读作“er qian”而不是“liang qian”。 资源限制：时间限制：1.0s 内存限制：512.0MB 输入格式：有一个数字串，数值大小不超过2,000,000,000。 输出格式：是一个由小写英文字母，逗号和空格组成的字符串，表示该数的英文读法。 样例输入：1234567009 样例输出：shi er yi san qian si bai wu shi liu wan qi qian ling jiu 分析：具体的分析放在的代码的注释中，因为我技术有限这个代码应该还有不少的bug，希望大家再补充， "},{"title":"完美的代价","date":"2021-01-24T08:33:54.242Z","url":"/2021/01/24/%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["基础","/tags/%E5%9F%BA%E7%A1%80/"],["贪心算法","/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。 交换的定义是：交换两个相邻的字符 例如mamad 第一次交换 ad : mamda 第二次交换 md : madma 第三次交换 ma : madam (回文！完美！) 资源限制：时间限制：1.0s 内存限制：512.0MB 输入格式：第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000)第二行是一个字符串，长度为N.只包含小写字母 输出格式：如果可能，输出最少的交换次数。否则输出Impossible 样例输入：5mamad 样例输出：3 分析："},{"title":"矩形面积交","date":"2021-01-23T13:41:31.770Z","url":"/2021/01/23/%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E4%BA%A4/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["基础","/tags/%E5%9F%BA%E7%A1%80/"],["判断","/tags/%E5%88%A4%E6%96%AD/"],["线段交","/tags/%E7%BA%BF%E6%AE%B5%E4%BA%A4/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"题目描述：平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。 资源限制：时间限制：1.0s 内存限制：512.0MB 输入格式：输入仅包含两行，每行描述一个矩形。在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。 输出格式：输出仅包含一个实数，为交的面积，保留到小数后两位。 样例输入：1 1 3 32 2 4 4 样例输出：1.00 分析：本题的意思是打出两个矩形的对角顶点坐标，通过顶点坐标来确定一个矩形，如图 由图可得知顶点bc组成的矩形的面积是所求的面积，可以看出b点是两个下顶点中较大的一个，c点是较小的一个，但情况不止这一种，如下图 由此图得知，点b不是两个下顶点中的任意一个，而是由两个下顶点中较大的横坐标和较大的纵坐标组成的，点c同理，故我们只要再设一个数组来储存符合要求的坐标即可。 但是，除了相交的情况还有不相交的情况， 则还需要几个if来判断。 以上都是在输入为下顶点加上顶点的情况下成立的，所以我们还要设置一个方法来判断是否输入的是下顶点加上顶点的格式，若不是则交换位置。 "},{"title":"矩阵乘法","date":"2021-01-22T09:38:25.141Z","url":"/2021/01/22/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["循环","/tags/%E5%BE%AA%E7%8E%AF/"],["基础","/tags/%E5%9F%BA%E7%A1%80/"],["二维数组","/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"],["矩阵","/tags/%E7%9F%A9%E9%98%B5/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：给定一个N阶矩阵A，输出A的M次幂（M是非负整数） 例如： A = 1 2 3 4 A的2次幂 7 10 15 22 资源限制：时间限制：1.0s 内存限制：512.0MB 输入格式：第一行是一个正整数N、M（1&lt;=N&lt;=30, 0&lt;=M&lt;=5），表示矩阵A的阶数和要求的幂数 接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值 输出格式：输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开 样例输入：2 21 23 4 样例输出：7 1015 22 分析：写这一题之前，先得学会矩阵乘法， 然后我们定义一个存放原始矩阵的数组，再定义一个用与存放结果的数组，然后开始循环，因为一个矩阵的零次幂一定是单位矩阵，而且已经将结果数组中加入了原始数组，这样幂等于一的时候也可以不用加入循环，故，只要从幂为二时开始循环 "},{"title":"分解质因数","date":"2021-01-22T06:11:56.814Z","url":"/2021/01/22/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["循环","/tags/%E5%BE%AA%E7%8E%AF/"],["基础","/tags/%E5%9F%BA%E7%A1%80/"],["质数分解","/tags/%E8%B4%A8%E6%95%B0%E5%88%86%E8%A7%A3/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：求出区间[a,b]中所有整数的质因数分解。 资源限制：时间限制：1.0s 内存限制：512.0MB 输入格式：输入两个整数a，b。 输出格式：每行输出一个数的分解，形如k=a1a2a3…(a1&lt;=a2&lt;=a3…，k也是从小到大的)(具体可看样例) 样例输入：3 10 样例输出：3=34=225=56=237=78=2229=3310=25 提示：先筛出所有素数，然后再分解。 数据规模和约定：2&lt;=a&lt;=b&lt;=10000 分析：先定义了一个用于判断是不是素数的方法，如果是素数就可以直接输出了（不定义这玩意好像也无所谓），再定义一个方法用于分解素数，思路如下：如果这个数刚好能被i整除那么打印这个数加*再将这个数除i进入下一次递归，若不是因子则使i加一进入下一次递归，若这个数等于i，则直接输出这个数不用输出乘号。 "},{"title":"十六进制转八进制(误)","date":"2021-01-22T05:35:47.366Z","url":"/2021/01/22/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%85%AB%E8%BF%9B%E5%88%B6/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["循环","/tags/%E5%BE%AA%E7%8E%AF/"],["进制转换","/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"],["基础","/tags/%E5%9F%BA%E7%A1%80/"],["字符处理","/tags/%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86/"],["判断","/tags/%E5%88%A4%E6%96%AD/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：给定n个十六进制正整数，输出它们对应的八进制数。 资源限制：时间限制：1.0s 内存限制：512.0MB 输入格式：输入的第一行为一个正整数n （1&lt;=n&lt;=10）。 接下来n行，每行一个由09、大写字母AF组成的字符串，表示要转换的十六进制正整数，每个十六进制数长度不超过100000。 输出格式：输出n行，每行为输入对应的八进制正整数。 【注意】 输入的十六进制数不会有前导0，比如012A。 输出的八进制数也不能有前导0。 样例输入：​ 2 39 123ABC 样例输出：​ 71 4435274 【提示】 先将十六进制数转换成某进制数，再由某进制数转换成八进制。 分析：一看这题，以为就是把16进制转换成十进制再转换成八进制，还给了个提示，我寻思着这谁想不到呀，就开始写了，写完之后发现，嗯？ 这测试数据就离谱。我也意识到同类型最大的十六进制远比同类型最大的十进制要大得多，所以转化到十进制的时候必会溢出。于是我又去康了康别人写的怎么样。恍然大悟，可以用字符串来表示二进制一组一组的进行转化。先通过8421法转化成二进制再用421法转化为八进制。于是就有了下面的代码 测试了一下好像完全符合要求，结果。。。 我是sb"},{"title":"字符串对比","date":"2021-01-21T03:01:44.672Z","url":"/2021/01/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E6%AF%94/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["基础","/tags/%E5%9F%BA%E7%A1%80/"],["字符串","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"],["大小写","/tags/%E5%A4%A7%E5%B0%8F%E5%86%99/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4中情况之一： 1：两个字符串长度不等。比如 Beijing 和 Hebei 2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如 Beijing 和 Beijing 3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如 beijing 和 BEIjing 4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing 编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。 资源限制：时间限制：1.0s 内存限制：512.0MB 输入格式：包括两行，每行都是一个字符串 输出格式：仅有一个数字，表明这两个字符串的关系编号 样例输入：BEIjing beiJing 样例输出：3 分析："},{"title":"时间转换","date":"2021-01-21T02:45:56.251Z","url":"/2021/01/21/%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["基础","/tags/%E5%9F%BA%E7%A1%80/"],["取余","/tags/%E5%8F%96%E4%BD%99/"],["数字字符混合输出","/tags/%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E6%B7%B7%E5%90%88%E8%BE%93%E5%87%BA/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：给定一个以秒为单位的时间t，要求用“&lt;/H/&gt;:&lt;/M/&gt;:&lt;/S/&gt;”的格式来表示这个时间。&lt;/H/&gt;表示时间，&lt;/M/&gt;表示分钟，而&lt;/S/&gt;表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。 资源限制：时间限制：1.0s 内存限制：512.0MB 输入格式：输入只有一行，是一个整数t（0&lt;=t&lt;=86399）。 输出格式：输出只有一行，是以“&lt;/H/&gt;:&lt;/M/&gt;:&lt;/S/&gt;”的格式所表示的时间，不包括引号。 样例输入：0 样例输出：0:0:0 样例输入：5436 样例输出：1:30:36 分析："},{"title":"十六进制转十进制","date":"2021-01-19T07:40:45.604Z","url":"/2021/01/19/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["进制转换","/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"],["基础","/tags/%E5%9F%BA%E7%A1%80/"],["字符处理","/tags/%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86/"],["判断","/tags/%E5%88%A4%E6%96%AD/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：从键盘输入一个不超过8位的正的十六进制数字符串，将它转换为正的十进制数后输出。 注：十六进制数中的10~15分别用大写的英文字母A、B、C、D、E、F表示。 资源限制：时间限制：1.0s 内存限制：512.0MB 样例输入：FFFF 样例输出：65535 分析：把十进制转化为十六进制只需要把十进制数的n位乘16的n减一次方即可。把A转化为10则用了ASCII码的偏差值，A的ASCII码是65，所以只需要将ASCII码大于65的值减65加10就可得到十进制数。 "},{"title":"特殊回文数","date":"2021-01-18T15:33:11.440Z","url":"/2021/01/18/%E7%89%B9%E6%AE%8A%E5%9B%9E%E6%96%87%E6%95%B0/","tags":[["入门","/tags/%E5%85%A5%E9%97%A8/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["循环","/tags/%E5%BE%AA%E7%8E%AF/"],["回文数","/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"],["条件语句","/tags/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：123321是一个非常特殊的数，它从左边读和从右边读是一样的。 输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。 资源限制：时间限制：1.0s 内存限制：512.0MB 输入格式：输入一行，包含一个正整数n。 输出格式：按从小到大的顺序输出满足条件的整数，每个整数占一行。 样例输入：52 样例输出：899998989989998899 数据规模和约定：1&lt;=n&lt;=54。 分析："},{"title":"回文数","date":"2021-01-18T15:13:57.362Z","url":"/2021/01/18/%E5%9B%9E%E6%96%87%E6%95%B0/","tags":[["入门","/tags/%E5%85%A5%E9%97%A8/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["循环","/tags/%E5%BE%AA%E7%8E%AF/"],["判断","/tags/%E5%88%A4%E6%96%AD/"],["回文数","/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：1221是一个非常特殊的数，它从左边读和从右边读是一样的，编程求所有这样的四位十进制数。 资源限制：时间限制：1.0s 内存限制：512.0MB 输出格式：按从小到大的顺序输出满足条件的四位十进制数。 分析："},{"title":"特殊的数字","date":"2021-01-18T14:42:00.640Z","url":"/2021/01/18/%E7%89%B9%E6%AE%8A%E7%9A%84%E6%95%B0%E5%AD%97/","tags":[["入门","/tags/%E5%85%A5%E9%97%A8/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["循环","/tags/%E5%BE%AA%E7%8E%AF/"],["判断","/tags/%E5%88%A4%E6%96%AD/"],["数位","/tags/%E6%95%B0%E4%BD%8D/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：153是一个非常特殊的数，它等于它的每位数字的立方和，即153=111+555+333。编程求所有满足这种条件的三位十进制数。 资源限制：时间限制：1.0s 内存限制：512.0MB 输出格式：按从小到大的顺序输出满足条件的三位十进制数，每个数占一行。 分析：通过分离个位、十位、百位可以很轻松得出答案 "},{"title":"杨辉三角","date":"2021-01-18T13:10:47.515Z","url":"/2021/01/18/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/","tags":[["入门","/tags/%E5%85%A5%E9%97%A8/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["二维数组","/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。 它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。 下面给出了杨辉三角形的前4行： 1 1 1 1 2 1 1 3 3 1 给出n，输出它的前n行。 资源限制：时间限制：1.0s 内存限制：256.0MB 输入格式：输入包含一个数n。 输出格式：输出杨辉三角形的前n行。每一行从这一行的第一个数开始依次输出，中间使用一个空格分隔。请不要在前面输出多余的空格。 样例输入：4 样例输出：11 11 2 11 3 3 1 数据规模与约定：1 &lt;= n &lt;= 34。 分析：首先定义一个二维数组，根据杨辉三角的规律，第n行有n个数，且每行的第一个和最后一个数都是1，第n行的第i个数字等于n-1行的i-1加上i "},{"title":"查找整数","date":"2021-01-18T08:55:52.549Z","url":"/2021/01/18/%E6%9F%A5%E6%89%BE%E6%95%B4%E6%95%B0/","tags":[["入门","/tags/%E5%85%A5%E9%97%A8/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["循环","/tags/%E5%BE%AA%E7%8E%AF/"],["判断","/tags/%E5%88%A4%E6%96%AD/"],["多行输入","/tags/%E5%A4%9A%E8%A1%8C%E8%BE%93%E5%85%A5/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"题目描述：给出一个包含n个整数的数列，问整数a在数列中的第一次出现是第几个。 资源限制：时间限制：1.0s 内存限制：256.0MB 输入格式：第一行包含一个整数n。 第二行包含n个非负整数，为给定的数列，数列中的每个数都不大于10000。 第三行包含一个整数a，为待查找的数。 输出格式：如果a在数列中出现了，输出它第一次出现的位置(位置从1开始编号)，否则输出-1。 样例输入：61 9 4 8 3 99 样例输出：2 数据规模与约定：1 &lt;= n &lt;= 1000。 分析："},{"title":"数列特征","date":"2021-01-18T08:12:48.225Z","url":"/2021/01/18/%E6%95%B0%E5%88%97%E7%89%B9%E5%BE%81/","tags":[["入门","/tags/%E5%85%A5%E9%97%A8/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["循环","/tags/%E5%BE%AA%E7%8E%AF/"],["最大值","/tags/%E6%9C%80%E5%A4%A7%E5%80%BC/"],["最小值","/tags/%E6%9C%80%E5%B0%8F%E5%80%BC/"],["累加","/tags/%E7%B4%AF%E5%8A%A0/"],["多行输入","/tags/%E5%A4%9A%E8%A1%8C%E8%BE%93%E5%85%A5/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"题目描述：给出n个数，找出这n个数的最大值，最小值，和。 资源限制：时间限制：1.0s 内存限制：256.0MB 输入格式：第一行为整数n，表示数的个数。 第二行有n个数，为给定的n个数，每个数的绝对值都小于10000。 输出格式：输出三行，每行一个整数。第一行表示这些数中的最大值，第二行表示这些数中的最小值，第三行表示这些数的和。 样例输入：51 3 -2 4 5 样例输出：5-211 数据规模与约定：1 &lt;= n &lt;= 10000。 分析：第一次见这题，不是因为题目的逻辑有多难，而是不知道怎么实现多行输入并且逐个处理。 "},{"title":"字母图形","date":"2021-01-17T15:03:11.121Z","url":"/2021/01/17/%E5%AD%97%E6%AF%8D%E5%9B%BE%E5%BD%A2/","tags":[["入门","/tags/%E5%85%A5%E9%97%A8/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["循环","/tags/%E5%BE%AA%E7%8E%AF/"],["字符串","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：利用字母可以组成一些美丽的图形，下面给出了一个例子： ABCDEFG BABCDEF CBABCDE DCBABCD EDCBABC 这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。 资源限制：时间限制：1.0s 内存限制：256.0MB 输入格式：输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。 输出格式：输出n行，每个m个字符，为你的图形。 样例输入：5 7 样例输出：ABCDEFGBABCDEFCBABCDEDCBABCDEDCBABC 数据规模与约定：1 &lt;= n, m &lt;= 26。 分析：这题就是一个找规律的题，先设一个char为65来表示A，接下来我们就可以通过对char的加减来实现字母的变化，我们再设一个外层循环来设定要打印的行数，然后这个外层循环内有两个内部循环，第一个内部循环是打印A之前的数的，比如第一行从A开始，这个内层循环就不需要打印，第二行A的前面有B，所以要输出B。第二个循环则是输出从A开始列数减第一个循环输出的个数。 因为第一层循环的偏移量和列数的循环是相等的，也就是说输出第零行的时候偏移量也是零不用输出，当然也不能大于列数。"},{"title":"01字串","date":"2021-01-16T15:56:06.135Z","url":"/2021/01/16/01%E5%AD%97%E4%B8%B2/","tags":[["入门","/tags/%E5%85%A5%E9%97%A8/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["循环","/tags/%E5%BE%AA%E7%8E%AF/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是： 00000 00001 00010 00011 00100 请按从小到大的顺序输出这32种01串。 资源限制：时间限制：1.0s 内存限制：256.0MB 输入格式：本题没有输入格式 输出格式：输出32行，按从小到大的顺序每行一个长度为5的01串。 样例输出：00000000010001000011&lt;以下部分省略&gt; 分析：这题只需要从0循环31次，再将他们的二进制输出即可 这个方法转化为二进制能选择保留的位数，原理是依次将最高位左移到最低位，再与1&amp;运算。"},{"title":"闰年判断","date":"2021-01-16T15:47:50.667Z","url":"/2021/01/16/%E9%97%B0%E5%B9%B4%E5%88%A4%E6%96%AD/","tags":[["入门","/tags/%E5%85%A5%E9%97%A8/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["条件判断","/tags/%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["基础练习","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"]],"content":"问题描述：给定一个年份，判断这一年是不是闰年。 当以下情况之一满足时，这一年是闰年： \\1. 年份是4的倍数而不是100的倍数； \\2. 年份是400的倍数。 其他的年份都不是闰年。 资源限制：时间限制：1.0s 内存限制：256.0MB 输入格式：输入包含一个整数y，表示当前的年份。 输出格式：输出一行，如果给定的年份是闰年，则输出yes，否则输出no。 样例输入：2013 样例输出：no 样例输入：2016 样例输出：yes 数据规模与约定：1990 &lt;= y &lt;= 2050。 分析：只要判断x除以y是否为0，就可以知道x能不能被y整除了。 "},{"title":"圆的面积","date":"2021-01-16T14:31:20.256Z","url":"/2021/01/16/%E5%9C%86%E7%9A%84%E9%9D%A2%E7%A7%AF/","tags":[["入门","/tags/%E5%85%A5%E9%97%A8/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["实数输出","/tags/%E5%AE%9E%E6%95%B0%E8%BE%93%E5%87%BA/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["入门训练","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%85%A5%E9%97%A8%E8%AE%AD%E7%BB%83/"]],"content":"题目描述：给定圆的半径r，求圆的面积。 资源限制：时间限制：1.0s 内存限制：256.0MB 输入格式：输入包含一个整数r，表示圆的半径。 输出格式：输出一行，包含一个实数，四舍五入保留小数点后7位，表示圆的面积。 样例输入：4 样例输出：50.2654825 数据规模与约定：1&lt;=r&lt;=10000 提示：本题对精度要求较高，请注意π的值应该取较精确的值。你可以使用常量来表示π，比如PI=3.14159265358979323，也可以使用数学公式来求π，比如PI=atan(1.0)*4。 分析：java中保留n为小数的写法为（不唯一） String.format(“%.nf”, x) n为保留的小数位，x必须为double类型。 "},{"title":"斐波那契数列","date":"2021-01-16T08:31:44.634Z","url":"/2021/01/16/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","tags":[["入门","/tags/%E5%85%A5%E9%97%A8/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["数列","/tags/%E6%95%B0%E5%88%97/"],["取模","/tags/%E5%8F%96%E6%A8%A1/"],["递归","/tags/%E9%80%92%E5%BD%92/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["练习题","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/"],["入门训练","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%85%A5%E9%97%A8%E8%AE%AD%E7%BB%83/"]],"content":"问题描述：Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 资源限制：时间限制：1.0s 内存限制：256.0MB 输入格式：输入包含一个整数n。 输出格式：输出一行，包含一个整数，表示Fn除以10007的余数。 样例输入：10 样例输出：55 样例输入：22 样例输出：7704 数据规模与约定：1&lt;=n&lt;=1000000. 分析：方法一：定义一个数组长度为n的数组，把数组的第一位和第二位都设为1，再通过循环使数组从第三位开始的后一位等于前两位的合。 方法二：第二种方法用的是递归，从最上层递归下来，但是一旦运算的数字变大，递归算法的重复运算太多，因为算f(n-1)的时候要算f(n-3)，算f(n-2)的时候还要算f(n-3)，不符合题目的资源要求。 方法三：通过循环加交换变量的值就能得出 "},{"title":"一条语句判断整数是不是2的整数次方","date":"2021-01-15T09:45:05.235Z","url":"/2021/01/15/%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E5%88%A4%E6%96%AD%E6%95%B4%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF2%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["位运算","/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["位运算的奇巧淫技","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"]],"content":"题目描述：一条语句判断整数是不是2的整数次方 分析：把一个数转化为二进制，如果这个二进制只有一位是1其余都是0那么这个二进制就是二的整数次方 "},{"title":"一题三解：计算二进制中1的个数","date":"2021-01-15T09:26:28.679Z","url":"/2021/01/15/%E4%B8%80%E9%A2%98%E4%B8%89%E8%A7%A3%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["位运算","/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["位运算的奇巧淫技","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"]],"content":"题目描述：请实现一个函数，输入一个整数，输出该二进制表示中1的个数 例：9的二进制表示为1001，有2位是1 方案一：第一种方法：假设这个数是3，其二进制为011，首先将011&amp;001，判断得出来的结果是否等于001，如果等于，说明这个第1位是1；然后将 011&amp;010，判断得出来的结果是否等于010，如果等于，说明这个第2位是1，一直进行下去，判断31位 方案二：第二种方法：只让要测验的数向右移。假设这个数是3，其二进制为011，首先将011&amp;001，判断得出来的结果是否等于001，如果等于，说明这个 第1位是1；然后将001&amp;001，判断得出来的结果是否等于001，如果等于，说明这个第2位是1，一直进行下去，判断31位 方案三：第三种方法：还是假设这个数是3，那我们让3变成0的过程中肯定是要消掉1的，消掉多少次1，就表示3的二进制中有多少个1。关键就在于，如何 消掉011中的1，我们首先让011减1，那么011就变成了010，然后让011&amp;010，就得到了010，然后再让010减1，那么010就变成了001，然后让 010&amp;001，就得到了000，转换成伪代码的形式就是，a = (a - 1) &amp; a，它的效果就是消掉最低位上的1，依次消掉所有最低位上的1，最后不就变成了0吗 "},{"title":"题解：如何找数组中唯一成对的那个数","date":"2021-01-15T08:13:35.166Z","url":"/2021/01/15/%E9%A2%98%E8%A7%A3%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E5%94%AF%E4%B8%80%E6%88%90%E5%AF%B9%E7%9A%84%E9%82%A3%E4%B8%AA%E6%95%B0/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["位运算","/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["位运算的奇巧淫技","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"]],"content":"题目描述：1-1000这1000个数放在含有1001个元素的数组中，只有唯一的一个元素值重复，其他均只出现一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助储存空间，能否设计一个算法实现？ 分析：根据a^a=0,a^0=a这两条性质，我们可以把数组中的元素全部异或起来，然后再异或一遍不重复的所有元素，就是(1^2^3^4^2)^(1^2^3^4)，这样把它们凑起来，最后结果就应该是2^2^2=2^0=2，正好是要找的重复元素 "},{"title":"回文字符串的判断","date":"2021-01-14T15:51:35.156Z","url":"/2021/01/14/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A4%E6%96%AD/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["算法基础","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"]],"content":"概念： 设n是一任意自然数。若将n的各位数字反向排列所得自然数n1与n相等，则称n为一回文数。例如，若n=1234321，则称n为一回文数；但若n=1234567，则n不是回文数。 分析： 设置两个指针，一个从第一个开始，一个从后面开始，循环比较两个指针指向的字符是否相等 "},{"title":"找出距离最小的点对","date":"2021-01-14T13:41:10.443Z","url":"/2021/01/14/%E6%89%BE%E5%87%BA%E8%B7%9D%E7%A6%BB%E6%9C%80%E5%B0%8F%E7%9A%84%E7%82%B9%E5%AF%B9/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["算法基础","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"]],"content":" 分析： 依次把每个点作为起点，计算和其余点的距离，保留更小的距离 "},{"title":"10进制数转16进制","date":"2021-01-12T06:53:17.983Z","url":"/2021/01/12/10%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC16%E8%BF%9B%E5%88%B6/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["进制转换","/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["算法基础","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"],["进制转换","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"]],"content":"已知：十进制数123被转换为十六进制数7B。这个转换过程如下：将123除以16，余数为11（十六进制的B）商为7.继续将7除以16，余数为7，商为0.因此7B就是123的十六进制数。 "},{"title":"位运算","date":"2021-01-11T10:03:21.130Z","url":"/2021/01/11/%E4%BD%8D%E8%BF%90%E7%AE%97/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["位运算","/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"],["算法","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"],["java","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/"],["蓝桥杯","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/"],["算法基础","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"],["位运算","/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/java/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BD%8D%E8%BF%90%E7%AE%97/"]],"content":"位运算1.位运算概述 程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。比如，and运算本来是一个逻辑运算符，但整数与整数之间也可以进行and运算。举个例子，6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它是二进制对应位进行逻辑运算的结果（0表示False，1表示True，空位都当0处理）。 110 AND 1011 0010 –&gt; 2 ——引用自百度 2.位运算运算符与运算(&amp;)把参加运算的数转化为二进制(不足的位补0)，按二进制位做逻辑上的与运算，1为true，0为false。 0&amp;0=0 0&amp;1=0 1&amp;0=0 1&amp;1=1 或运算(|)把参加运算的数转化为二进制(不足的位补0)，按二进制位做逻辑上的或运算，1为true，0为false。 0|0=0 0|1=1 1|0=1 1|1=1 异或运算(^)首先异或操作是对每一位都进行异或（相同为0，不同为1），但需要先把数转换成补码才行。 1、正数的补码即本身 2、负数的补码为各位取反然后加1（最高为保持为1不变） 把参加运算的数转化为二进制(不足的位补0)，两个数相同为0，相异为1。 0^0=0 0^1=1 1^0=1 1^1=0 异或的几条性质: 1、交换律 2、结合律 (a^b)^c == a^(b^c) 3、对于任何数x，都有 x^x=0，x^0=x 4、自反性: a^b^b=a^0=a; 取反运算(~)把参加运算的数转化为二进制(不足的位补0)，做逻辑上的取反。 ~1=0 ~0=1 左移运算(&lt;&lt;)把参加运算的数转化为二进制(不足的位补0)，左移若干位 (左边不要，右边补0)。 1010 &lt;&lt; 2 就是左移两位得到 1000 若左移时舍弃的高位补包含1，则每左移一位，相当于该数乘以2。 对于int型，1&lt;&lt;35与1&lt;&lt;3是相同的，因为int总共就32位，向左边移35位的时候会取模。 右移运算(&gt;&gt;)把参加运算的数转化为二进制(不足的位补0)，右移若干位 (正数左边补0，负数左边补1，右边不要)。 操作数右移一位，就相当于概述除以2。 右移运算(&gt;&gt;&gt;)把参加运算的数转化为二进制(不足的位补0)，右移若干位 (左边补0，右边不要)。 没有&lt;&lt;&lt;运算符3.例题把2变成8最高效的方式是什么2 &lt;&lt; 2=8 判断奇偶数二进制数的最后以为是1就是奇数，最后一位是0就是偶数，因为前面都是二的次方所以一定是偶数，所以只要判断最后一位就行了。 让被判断的数的最后的一位和1做与运算，结果为0就是偶数，为1就是奇数。 获取二进制位是1还是0(两种解决方案)方案一 求x的第5位 先让1左移4位得00010000，与x进行与运算，得到的结果再右移4位判断得到的是1还是0。 方案二 将x右移4位与1进行与运算 交换两个整数变量的值A=A^B B=A^B C=A^B 不用判断语句，求整数的绝对值负数的补码为各位取反然后加1(最高位保持为1不变) 先把要求的数设为A带符号往右移31位设为x，若A为正数那x就0，为负数则为-1(111111..第一个1表符号)，将A和x做异或运算，若A为正数那么运算结果就是自己，若A为负数结果则为~A(取反)，因为取反后还要加一，通过A&gt;&gt;&gt;31(结果为0或1)来决定要不要加一。 "},{"title":"Hello World","date":"2021-01-08T10:52:08.837Z","url":"/2021/01/08/hello-world/","tags":[["-意义不明","/tags/%E6%84%8F%E4%B9%89%E4%B8%8D%E6%98%8E/"]],"categories":[["意义不明","/categories/%E6%84%8F%E4%B9%89%E4%B8%8D%E6%98%8E/"]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]